-- mySort file

**Heap Sort Overview**
Heap sort is a binary sorting technique that uses comparison sorting. It operates with a time complexity of O(n log n)

**Advantages:**
- Efficient in terms of time complexity.
- Requires minimal memory storage.
- Simple to learn and implement as a sorting method.

**Disadvantages:**
- Unstable: it might rearrange the relative order of equal elements in the array.

**Sorting Process**
Heap sort occurs in two phases:
1. Convert the array into a max heap.
2. Remove the highest element and create a new max heap with the remaining elements.

---

**Pseudocode for Heap Sort Algorithm:**

FUNCTION HeapSort(array) n = LENGTH(array)
// Build the heap
FOR i FROM n/2 - 1 DOWNTO 0 DO
    heapify(array, n, i)
END FOR

// Move the largest element to the end and re-heapify
FOR i FROM n - 1 DOWNTO 1 DO
    Swap(array, 0, i) // Swap the largest element with the last
    heapify(array, i, 0) // Re-heapify the reduced heap
END FOR
--------------------------------------------------------------
FUNCTION HeapSort(array, shpComp) n = LENGTH(array)
// Build the heap using the comparator
FOR i FROM n/2 - 1 DOWNTO 0 DO
    heapify(array, n, i, shpComp)
END FOR

// Move the largest element to the end and re-heapify
FOR i FROM n - 1 DOWNTO 1 DO
    Swap(array, 0, i) // Swap the largest element with the last
    heapify(array, i, 0, shpComp) // Re-heapify the reduced heap
END FOR
---------------------------------------------------------------
FUNCTION heapify(array, n, i) largest = i left = 2 * i + 1 right = 2 * i + 2
// Check if left child is larger
IF left < n AND array[left] < array[largest] THEN
    largest = left
END IF

// Check if right child is larger
IF right < n AND array[right] < array[largest] THEN
    largest = right
END IF

// If largest is not the current element, swap and heapify again
IF largest != i THEN
    Swap(array, i, largest)
    heapify(array, n, largest)
END IF
---------------------------------------------------------------
FUNCTION heapify(array, n, i, shpComp) largest = i left = 2 * i + 1 right = 2 * i + 2
// Check if left child is larger using comparator
IF left < n AND shpComp.compare(array[left], array[largest]) < 0 THEN
    largest = left
END IF

// Check if right child is larger using comparator
IF right < n AND shpComp.compare(array[right], array[largest]) < 0 THEN
    largest = right
END IF

// If largest is not the current element, swap and heapify again
IF largest != i THEN
    Swap(array, i, largest)
    heapify(array, n, largest, shpComp)
END IF
---------------------------------------------------------------
**Reference:**
[GeeksforGeeks - Heap Sort](https://www.geeksforgeeks.org/heap-sort/)
